// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/KirillMironov/ai/internal/model"
	"sync"
)

// AuthenticatorService is a mock implementation of service.authenticatorService.
//
//	func TestSomethingThatUsesauthenticatorService(t *testing.T) {
//
//		// make and configure a mocked service.authenticatorService
//		mockedauthenticatorService := &AuthenticatorService{
//			AuthenticateFunc: func(token string) (model.TokenPayload, error) {
//				panic("mock out the Authenticate method")
//			},
//		}
//
//		// use mockedauthenticatorService in code that requires service.authenticatorService
//		// and then make assertions.
//
//	}
type AuthenticatorService struct {
	// AuthenticateFunc mocks the Authenticate method.
	AuthenticateFunc func(token string) (model.TokenPayload, error)

	// calls tracks calls to the methods.
	calls struct {
		// Authenticate holds details about calls to the Authenticate method.
		Authenticate []struct {
			// Token is the token argument value.
			Token string
		}
	}
	lockAuthenticate sync.RWMutex
}

// Authenticate calls AuthenticateFunc.
func (mock *AuthenticatorService) Authenticate(token string) (model.TokenPayload, error) {
	if mock.AuthenticateFunc == nil {
		panic("AuthenticatorService.AuthenticateFunc: method is nil but authenticatorService.Authenticate was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	mock.lockAuthenticate.Lock()
	mock.calls.Authenticate = append(mock.calls.Authenticate, callInfo)
	mock.lockAuthenticate.Unlock()
	return mock.AuthenticateFunc(token)
}

// AuthenticateCalls gets all the calls that were made to Authenticate.
// Check the length with:
//
//	len(mockedauthenticatorService.AuthenticateCalls())
func (mock *AuthenticatorService) AuthenticateCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	mock.lockAuthenticate.RLock()
	calls = mock.calls.Authenticate
	mock.lockAuthenticate.RUnlock()
	return calls
}

// ConversationsStorage is a mock implementation of service.conversationsStorage.
//
//	func TestSomethingThatUsesconversationsStorage(t *testing.T) {
//
//		// make and configure a mocked service.conversationsStorage
//		mockedconversationsStorage := &ConversationsStorage{
//			GetConversationByIDFunc: func(ctx context.Context, id string) (model.Conversation, bool, error) {
//				panic("mock out the GetConversationByID method")
//			},
//			GetConversationsByUserIDFunc: func(ctx context.Context, userID string, offset int, limit int) ([]model.Conversation, error) {
//				panic("mock out the GetConversationsByUserID method")
//			},
//			SaveConversationFunc: func(ctx context.Context, conversation model.Conversation) error {
//				panic("mock out the SaveConversation method")
//			},
//		}
//
//		// use mockedconversationsStorage in code that requires service.conversationsStorage
//		// and then make assertions.
//
//	}
type ConversationsStorage struct {
	// GetConversationByIDFunc mocks the GetConversationByID method.
	GetConversationByIDFunc func(ctx context.Context, id string) (model.Conversation, bool, error)

	// GetConversationsByUserIDFunc mocks the GetConversationsByUserID method.
	GetConversationsByUserIDFunc func(ctx context.Context, userID string, offset int, limit int) ([]model.Conversation, error)

	// SaveConversationFunc mocks the SaveConversation method.
	SaveConversationFunc func(ctx context.Context, conversation model.Conversation) error

	// calls tracks calls to the methods.
	calls struct {
		// GetConversationByID holds details about calls to the GetConversationByID method.
		GetConversationByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetConversationsByUserID holds details about calls to the GetConversationsByUserID method.
		GetConversationsByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// SaveConversation holds details about calls to the SaveConversation method.
		SaveConversation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Conversation is the conversation argument value.
			Conversation model.Conversation
		}
	}
	lockGetConversationByID      sync.RWMutex
	lockGetConversationsByUserID sync.RWMutex
	lockSaveConversation         sync.RWMutex
}

// GetConversationByID calls GetConversationByIDFunc.
func (mock *ConversationsStorage) GetConversationByID(ctx context.Context, id string) (model.Conversation, bool, error) {
	if mock.GetConversationByIDFunc == nil {
		panic("ConversationsStorage.GetConversationByIDFunc: method is nil but conversationsStorage.GetConversationByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetConversationByID.Lock()
	mock.calls.GetConversationByID = append(mock.calls.GetConversationByID, callInfo)
	mock.lockGetConversationByID.Unlock()
	return mock.GetConversationByIDFunc(ctx, id)
}

// GetConversationByIDCalls gets all the calls that were made to GetConversationByID.
// Check the length with:
//
//	len(mockedconversationsStorage.GetConversationByIDCalls())
func (mock *ConversationsStorage) GetConversationByIDCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetConversationByID.RLock()
	calls = mock.calls.GetConversationByID
	mock.lockGetConversationByID.RUnlock()
	return calls
}

// GetConversationsByUserID calls GetConversationsByUserIDFunc.
func (mock *ConversationsStorage) GetConversationsByUserID(ctx context.Context, userID string, offset int, limit int) ([]model.Conversation, error) {
	if mock.GetConversationsByUserIDFunc == nil {
		panic("ConversationsStorage.GetConversationsByUserIDFunc: method is nil but conversationsStorage.GetConversationsByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		UserID: userID,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetConversationsByUserID.Lock()
	mock.calls.GetConversationsByUserID = append(mock.calls.GetConversationsByUserID, callInfo)
	mock.lockGetConversationsByUserID.Unlock()
	return mock.GetConversationsByUserIDFunc(ctx, userID, offset, limit)
}

// GetConversationsByUserIDCalls gets all the calls that were made to GetConversationsByUserID.
// Check the length with:
//
//	len(mockedconversationsStorage.GetConversationsByUserIDCalls())
func (mock *ConversationsStorage) GetConversationsByUserIDCalls() []struct {
	Ctx    context.Context
	UserID string
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
		Offset int
		Limit  int
	}
	mock.lockGetConversationsByUserID.RLock()
	calls = mock.calls.GetConversationsByUserID
	mock.lockGetConversationsByUserID.RUnlock()
	return calls
}

// SaveConversation calls SaveConversationFunc.
func (mock *ConversationsStorage) SaveConversation(ctx context.Context, conversation model.Conversation) error {
	if mock.SaveConversationFunc == nil {
		panic("ConversationsStorage.SaveConversationFunc: method is nil but conversationsStorage.SaveConversation was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Conversation model.Conversation
	}{
		Ctx:          ctx,
		Conversation: conversation,
	}
	mock.lockSaveConversation.Lock()
	mock.calls.SaveConversation = append(mock.calls.SaveConversation, callInfo)
	mock.lockSaveConversation.Unlock()
	return mock.SaveConversationFunc(ctx, conversation)
}

// SaveConversationCalls gets all the calls that were made to SaveConversation.
// Check the length with:
//
//	len(mockedconversationsStorage.SaveConversationCalls())
func (mock *ConversationsStorage) SaveConversationCalls() []struct {
	Ctx          context.Context
	Conversation model.Conversation
} {
	var calls []struct {
		Ctx          context.Context
		Conversation model.Conversation
	}
	mock.lockSaveConversation.RLock()
	calls = mock.calls.SaveConversation
	mock.lockSaveConversation.RUnlock()
	return calls
}
