// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	context "context"
	"github.com/KirillMironov/ai/internal/api/llm"
	grpc "google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	sync "sync"
)

// LLMClient is a mock implementation of api.LLMClient.
//
//	func TestSomethingThatUsesLLMClient(t *testing.T) {
//
//		// make and configure a mocked api.LLMClient
//		mockedLLMClient := &LLMClient{
//			ChatCompletionFunc: func(ctx context.Context, in *api.ChatCompletionRequest, opts ...grpc.CallOption) (*api.ChatCompletionResponse, error) {
//				panic("mock out the ChatCompletion method")
//			},
//			ChatCompletionStreamFunc: func(ctx context.Context, in *api.ChatCompletionStreamRequest, opts ...grpc.CallOption) (api.LLM_ChatCompletionStreamClient, error) {
//				panic("mock out the ChatCompletionStream method")
//			},
//			CompletionFunc: func(ctx context.Context, in *api.CompletionRequest, opts ...grpc.CallOption) (*api.CompletionResponse, error) {
//				panic("mock out the Completion method")
//			},
//			CompletionStreamFunc: func(ctx context.Context, in *api.CompletionStreamRequest, opts ...grpc.CallOption) (api.LLM_CompletionStreamClient, error) {
//				panic("mock out the CompletionStream method")
//			},
//		}
//
//		// use mockedLLMClient in code that requires api.LLMClient
//		// and then make assertions.
//
//	}
type LLMClient struct {
	// ChatCompletionFunc mocks the ChatCompletion method.
	ChatCompletionFunc func(ctx context.Context, in *api.ChatCompletionRequest, opts ...grpc.CallOption) (*api.ChatCompletionResponse, error)

	// ChatCompletionStreamFunc mocks the ChatCompletionStream method.
	ChatCompletionStreamFunc func(ctx context.Context, in *api.ChatCompletionStreamRequest, opts ...grpc.CallOption) (api.LLM_ChatCompletionStreamClient, error)

	// CompletionFunc mocks the Completion method.
	CompletionFunc func(ctx context.Context, in *api.CompletionRequest, opts ...grpc.CallOption) (*api.CompletionResponse, error)

	// CompletionStreamFunc mocks the CompletionStream method.
	CompletionStreamFunc func(ctx context.Context, in *api.CompletionStreamRequest, opts ...grpc.CallOption) (api.LLM_CompletionStreamClient, error)

	// calls tracks calls to the methods.
	calls struct {
		// ChatCompletion holds details about calls to the ChatCompletion method.
		ChatCompletion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *api.ChatCompletionRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// ChatCompletionStream holds details about calls to the ChatCompletionStream method.
		ChatCompletionStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *api.ChatCompletionStreamRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Completion holds details about calls to the Completion method.
		Completion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *api.CompletionRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// CompletionStream holds details about calls to the CompletionStream method.
		CompletionStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *api.CompletionStreamRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockChatCompletion       sync.RWMutex
	lockChatCompletionStream sync.RWMutex
	lockCompletion           sync.RWMutex
	lockCompletionStream     sync.RWMutex
}

// ChatCompletion calls ChatCompletionFunc.
func (mock *LLMClient) ChatCompletion(ctx context.Context, in *api.ChatCompletionRequest, opts ...grpc.CallOption) (*api.ChatCompletionResponse, error) {
	if mock.ChatCompletionFunc == nil {
		panic("LLMClient.ChatCompletionFunc: method is nil but LLMClient.ChatCompletion was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *api.ChatCompletionRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockChatCompletion.Lock()
	mock.calls.ChatCompletion = append(mock.calls.ChatCompletion, callInfo)
	mock.lockChatCompletion.Unlock()
	return mock.ChatCompletionFunc(ctx, in, opts...)
}

// ChatCompletionCalls gets all the calls that were made to ChatCompletion.
// Check the length with:
//
//	len(mockedLLMClient.ChatCompletionCalls())
func (mock *LLMClient) ChatCompletionCalls() []struct {
	Ctx  context.Context
	In   *api.ChatCompletionRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *api.ChatCompletionRequest
		Opts []grpc.CallOption
	}
	mock.lockChatCompletion.RLock()
	calls = mock.calls.ChatCompletion
	mock.lockChatCompletion.RUnlock()
	return calls
}

// ChatCompletionStream calls ChatCompletionStreamFunc.
func (mock *LLMClient) ChatCompletionStream(ctx context.Context, in *api.ChatCompletionStreamRequest, opts ...grpc.CallOption) (api.LLM_ChatCompletionStreamClient, error) {
	if mock.ChatCompletionStreamFunc == nil {
		panic("LLMClient.ChatCompletionStreamFunc: method is nil but LLMClient.ChatCompletionStream was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *api.ChatCompletionStreamRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockChatCompletionStream.Lock()
	mock.calls.ChatCompletionStream = append(mock.calls.ChatCompletionStream, callInfo)
	mock.lockChatCompletionStream.Unlock()
	return mock.ChatCompletionStreamFunc(ctx, in, opts...)
}

// ChatCompletionStreamCalls gets all the calls that were made to ChatCompletionStream.
// Check the length with:
//
//	len(mockedLLMClient.ChatCompletionStreamCalls())
func (mock *LLMClient) ChatCompletionStreamCalls() []struct {
	Ctx  context.Context
	In   *api.ChatCompletionStreamRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *api.ChatCompletionStreamRequest
		Opts []grpc.CallOption
	}
	mock.lockChatCompletionStream.RLock()
	calls = mock.calls.ChatCompletionStream
	mock.lockChatCompletionStream.RUnlock()
	return calls
}

// Completion calls CompletionFunc.
func (mock *LLMClient) Completion(ctx context.Context, in *api.CompletionRequest, opts ...grpc.CallOption) (*api.CompletionResponse, error) {
	if mock.CompletionFunc == nil {
		panic("LLMClient.CompletionFunc: method is nil but LLMClient.Completion was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *api.CompletionRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCompletion.Lock()
	mock.calls.Completion = append(mock.calls.Completion, callInfo)
	mock.lockCompletion.Unlock()
	return mock.CompletionFunc(ctx, in, opts...)
}

// CompletionCalls gets all the calls that were made to Completion.
// Check the length with:
//
//	len(mockedLLMClient.CompletionCalls())
func (mock *LLMClient) CompletionCalls() []struct {
	Ctx  context.Context
	In   *api.CompletionRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *api.CompletionRequest
		Opts []grpc.CallOption
	}
	mock.lockCompletion.RLock()
	calls = mock.calls.Completion
	mock.lockCompletion.RUnlock()
	return calls
}

// CompletionStream calls CompletionStreamFunc.
func (mock *LLMClient) CompletionStream(ctx context.Context, in *api.CompletionStreamRequest, opts ...grpc.CallOption) (api.LLM_CompletionStreamClient, error) {
	if mock.CompletionStreamFunc == nil {
		panic("LLMClient.CompletionStreamFunc: method is nil but LLMClient.CompletionStream was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *api.CompletionStreamRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCompletionStream.Lock()
	mock.calls.CompletionStream = append(mock.calls.CompletionStream, callInfo)
	mock.lockCompletionStream.Unlock()
	return mock.CompletionStreamFunc(ctx, in, opts...)
}

// CompletionStreamCalls gets all the calls that were made to CompletionStream.
// Check the length with:
//
//	len(mockedLLMClient.CompletionStreamCalls())
func (mock *LLMClient) CompletionStreamCalls() []struct {
	Ctx  context.Context
	In   *api.CompletionStreamRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *api.CompletionStreamRequest
		Opts []grpc.CallOption
	}
	mock.lockCompletionStream.RLock()
	calls = mock.calls.CompletionStream
	mock.lockCompletionStream.RUnlock()
	return calls
}

// LLMChatCompletionStreamClient is a mock implementation of api.LLM_ChatCompletionStreamClient.
//
//	func TestSomethingThatUsesLLM_ChatCompletionStreamClient(t *testing.T) {
//
//		// make and configure a mocked api.LLM_ChatCompletionStreamClient
//		mockedLLM_ChatCompletionStreamClient := &LLMChatCompletionStreamClient{
//			CloseSendFunc: func() error {
//				panic("mock out the CloseSend method")
//			},
//			ContextFunc: func() context.Context {
//				panic("mock out the Context method")
//			},
//			HeaderFunc: func() (metadata.MD, error) {
//				panic("mock out the Header method")
//			},
//			RecvFunc: func() (*api.ChatCompletionStreamResponse, error) {
//				panic("mock out the Recv method")
//			},
//			RecvMsgFunc: func(m any) error {
//				panic("mock out the RecvMsg method")
//			},
//			SendMsgFunc: func(m any) error {
//				panic("mock out the SendMsg method")
//			},
//			TrailerFunc: func() metadata.MD {
//				panic("mock out the Trailer method")
//			},
//		}
//
//		// use mockedLLM_ChatCompletionStreamClient in code that requires api.LLM_ChatCompletionStreamClient
//		// and then make assertions.
//
//	}
type LLMChatCompletionStreamClient struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (metadata.MD, error)

	// RecvFunc mocks the Recv method.
	RecvFunc func() (*api.ChatCompletionStreamResponse, error)

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m any) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m any) error

	// TrailerFunc mocks the Trailer method.
	TrailerFunc func() metadata.MD

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M any
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M any
		}
		// Trailer holds details about calls to the Trailer method.
		Trailer []struct {
		}
	}
	lockCloseSend sync.RWMutex
	lockContext   sync.RWMutex
	lockHeader    sync.RWMutex
	lockRecv      sync.RWMutex
	lockRecvMsg   sync.RWMutex
	lockSendMsg   sync.RWMutex
	lockTrailer   sync.RWMutex
}

// CloseSend calls CloseSendFunc.
func (mock *LLMChatCompletionStreamClient) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("LLMChatCompletionStreamClient.CloseSendFunc: method is nil but LLM_ChatCompletionStreamClient.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	mock.lockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.CloseSendCalls())
func (mock *LLMChatCompletionStreamClient) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCloseSend.RLock()
	calls = mock.calls.CloseSend
	mock.lockCloseSend.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *LLMChatCompletionStreamClient) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("LLMChatCompletionStreamClient.ContextFunc: method is nil but LLM_ChatCompletionStreamClient.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.ContextCalls())
func (mock *LLMChatCompletionStreamClient) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *LLMChatCompletionStreamClient) Header() (metadata.MD, error) {
	if mock.HeaderFunc == nil {
		panic("LLMChatCompletionStreamClient.HeaderFunc: method is nil but LLM_ChatCompletionStreamClient.Header was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.HeaderCalls())
func (mock *LLMChatCompletionStreamClient) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *LLMChatCompletionStreamClient) Recv() (*api.ChatCompletionStreamResponse, error) {
	if mock.RecvFunc == nil {
		panic("LLMChatCompletionStreamClient.RecvFunc: method is nil but LLM_ChatCompletionStreamClient.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.RecvCalls())
func (mock *LLMChatCompletionStreamClient) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *LLMChatCompletionStreamClient) RecvMsg(m any) error {
	if mock.RecvMsgFunc == nil {
		panic("LLMChatCompletionStreamClient.RecvMsgFunc: method is nil but LLM_ChatCompletionStreamClient.RecvMsg was just called")
	}
	callInfo := struct {
		M any
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.RecvMsgCalls())
func (mock *LLMChatCompletionStreamClient) RecvMsgCalls() []struct {
	M any
} {
	var calls []struct {
		M any
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *LLMChatCompletionStreamClient) SendMsg(m any) error {
	if mock.SendMsgFunc == nil {
		panic("LLMChatCompletionStreamClient.SendMsgFunc: method is nil but LLM_ChatCompletionStreamClient.SendMsg was just called")
	}
	callInfo := struct {
		M any
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.SendMsgCalls())
func (mock *LLMChatCompletionStreamClient) SendMsgCalls() []struct {
	M any
} {
	var calls []struct {
		M any
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// Trailer calls TrailerFunc.
func (mock *LLMChatCompletionStreamClient) Trailer() metadata.MD {
	if mock.TrailerFunc == nil {
		panic("LLMChatCompletionStreamClient.TrailerFunc: method is nil but LLM_ChatCompletionStreamClient.Trailer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrailer.Lock()
	mock.calls.Trailer = append(mock.calls.Trailer, callInfo)
	mock.lockTrailer.Unlock()
	return mock.TrailerFunc()
}

// TrailerCalls gets all the calls that were made to Trailer.
// Check the length with:
//
//	len(mockedLLM_ChatCompletionStreamClient.TrailerCalls())
func (mock *LLMChatCompletionStreamClient) TrailerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrailer.RLock()
	calls = mock.calls.Trailer
	mock.lockTrailer.RUnlock()
	return calls
}
