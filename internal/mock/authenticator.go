// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/KirillMironov/ai/internal/model"
	"sync"
)

// UsersStorage is a mock implementation of service.usersStorage.
//
//	func TestSomethingThatUsesusersStorage(t *testing.T) {
//
//		// make and configure a mocked service.usersStorage
//		mockedusersStorage := &UsersStorage{
//			GetUserByUsernameFunc: func(ctx context.Context, username string) (model.User, bool, error) {
//				panic("mock out the GetUserByUsername method")
//			},
//			SaveUserFunc: func(ctx context.Context, user model.User) error {
//				panic("mock out the SaveUser method")
//			},
//		}
//
//		// use mockedusersStorage in code that requires service.usersStorage
//		// and then make assertions.
//
//	}
type UsersStorage struct {
	// GetUserByUsernameFunc mocks the GetUserByUsername method.
	GetUserByUsernameFunc func(ctx context.Context, username string) (model.User, bool, error)

	// SaveUserFunc mocks the SaveUser method.
	SaveUserFunc func(ctx context.Context, user model.User) error

	// calls tracks calls to the methods.
	calls struct {
		// GetUserByUsername holds details about calls to the GetUserByUsername method.
		GetUserByUsername []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// SaveUser holds details about calls to the SaveUser method.
		SaveUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User model.User
		}
	}
	lockGetUserByUsername sync.RWMutex
	lockSaveUser          sync.RWMutex
}

// GetUserByUsername calls GetUserByUsernameFunc.
func (mock *UsersStorage) GetUserByUsername(ctx context.Context, username string) (model.User, bool, error) {
	if mock.GetUserByUsernameFunc == nil {
		panic("UsersStorage.GetUserByUsernameFunc: method is nil but usersStorage.GetUserByUsername was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockGetUserByUsername.Lock()
	mock.calls.GetUserByUsername = append(mock.calls.GetUserByUsername, callInfo)
	mock.lockGetUserByUsername.Unlock()
	return mock.GetUserByUsernameFunc(ctx, username)
}

// GetUserByUsernameCalls gets all the calls that were made to GetUserByUsername.
// Check the length with:
//
//	len(mockedusersStorage.GetUserByUsernameCalls())
func (mock *UsersStorage) GetUserByUsernameCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockGetUserByUsername.RLock()
	calls = mock.calls.GetUserByUsername
	mock.lockGetUserByUsername.RUnlock()
	return calls
}

// SaveUser calls SaveUserFunc.
func (mock *UsersStorage) SaveUser(ctx context.Context, user model.User) error {
	if mock.SaveUserFunc == nil {
		panic("UsersStorage.SaveUserFunc: method is nil but usersStorage.SaveUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User model.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockSaveUser.Lock()
	mock.calls.SaveUser = append(mock.calls.SaveUser, callInfo)
	mock.lockSaveUser.Unlock()
	return mock.SaveUserFunc(ctx, user)
}

// SaveUserCalls gets all the calls that were made to SaveUser.
// Check the length with:
//
//	len(mockedusersStorage.SaveUserCalls())
func (mock *UsersStorage) SaveUserCalls() []struct {
	Ctx  context.Context
	User model.User
} {
	var calls []struct {
		Ctx  context.Context
		User model.User
	}
	mock.lockSaveUser.RLock()
	calls = mock.calls.SaveUser
	mock.lockSaveUser.RUnlock()
	return calls
}

// TokenManager is a mock implementation of service.tokenManager.
//
//	func TestSomethingThatUsestokenManager(t *testing.T) {
//
//		// make and configure a mocked service.tokenManager
//		mockedtokenManager := &TokenManager{
//			GenerateTokenFunc: func(payload model.TokenPayload) (string, error) {
//				panic("mock out the GenerateToken method")
//			},
//			ParseTokenFunc: func(token string) (model.TokenPayload, error) {
//				panic("mock out the ParseToken method")
//			},
//		}
//
//		// use mockedtokenManager in code that requires service.tokenManager
//		// and then make assertions.
//
//	}
type TokenManager struct {
	// GenerateTokenFunc mocks the GenerateToken method.
	GenerateTokenFunc func(payload model.TokenPayload) (string, error)

	// ParseTokenFunc mocks the ParseToken method.
	ParseTokenFunc func(token string) (model.TokenPayload, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateToken holds details about calls to the GenerateToken method.
		GenerateToken []struct {
			// Payload is the payload argument value.
			Payload model.TokenPayload
		}
		// ParseToken holds details about calls to the ParseToken method.
		ParseToken []struct {
			// Token is the token argument value.
			Token string
		}
	}
	lockGenerateToken sync.RWMutex
	lockParseToken    sync.RWMutex
}

// GenerateToken calls GenerateTokenFunc.
func (mock *TokenManager) GenerateToken(payload model.TokenPayload) (string, error) {
	if mock.GenerateTokenFunc == nil {
		panic("TokenManager.GenerateTokenFunc: method is nil but tokenManager.GenerateToken was just called")
	}
	callInfo := struct {
		Payload model.TokenPayload
	}{
		Payload: payload,
	}
	mock.lockGenerateToken.Lock()
	mock.calls.GenerateToken = append(mock.calls.GenerateToken, callInfo)
	mock.lockGenerateToken.Unlock()
	return mock.GenerateTokenFunc(payload)
}

// GenerateTokenCalls gets all the calls that were made to GenerateToken.
// Check the length with:
//
//	len(mockedtokenManager.GenerateTokenCalls())
func (mock *TokenManager) GenerateTokenCalls() []struct {
	Payload model.TokenPayload
} {
	var calls []struct {
		Payload model.TokenPayload
	}
	mock.lockGenerateToken.RLock()
	calls = mock.calls.GenerateToken
	mock.lockGenerateToken.RUnlock()
	return calls
}

// ParseToken calls ParseTokenFunc.
func (mock *TokenManager) ParseToken(token string) (model.TokenPayload, error) {
	if mock.ParseTokenFunc == nil {
		panic("TokenManager.ParseTokenFunc: method is nil but tokenManager.ParseToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	mock.lockParseToken.Lock()
	mock.calls.ParseToken = append(mock.calls.ParseToken, callInfo)
	mock.lockParseToken.Unlock()
	return mock.ParseTokenFunc(token)
}

// ParseTokenCalls gets all the calls that were made to ParseToken.
// Check the length with:
//
//	len(mockedtokenManager.ParseTokenCalls())
func (mock *TokenManager) ParseTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	mock.lockParseToken.RLock()
	calls = mock.calls.ParseToken
	mock.lockParseToken.RUnlock()
	return calls
}
